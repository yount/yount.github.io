<section class="page-header">
  <h1 class="project-name">Yount.GitHub.io</h1>
  <h2 class="project-tagline">website</h2>
</section>

<section class="main-content">
  <h3>
    <a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
      <span aria-hidden="true" class="octicon octicon-link"></span>
    </a>
    annotational 自定义注解
  </h3>

  <p>
  	元注解：生成自定义注解时使用，有@Target, @Rentention, @Documented 和 @Inherited 四个。
  </p>
  <p>
  	<br />

  </p>
  <p>
  	@Documented
  </p>
  <p>
  	若A_annotation被@Documented修饰过，则在生成文档时，被A_annotation修饰过的程序会出现关于A_annotation的描述信息。
  </p>
  <p>
  	<br />

  </p>
  <p>
  	@Target
  </p>
  <p>
  	用于说明自定义注解适用的范围，有以下集中参数：
  </p>
  <p>
  	ElementType.TYPE：适用范围为类、接口（包括注解类型的接口）或enum（Class, interface (including annotation type), or enum declaration）。
  </p>
  <p>
  	ElementType.FIELD：<span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">字段声明（包括枚举常量）</span>（Field declaration (includes enum constants)）。<br />

  </p>
  <p>
  	<span style="white-space:pre">					</span>字段：http://blog.csdn.net/ljz2009y/article/details/8023499
  </p>
  <p>
  	ElementType.METHOD：作用于方法（Method declaration）。<br />

  </p>
  <p>
  	ElementType.PARAMETER：作用于形参（Formal parameter declaration）。
  </p>
  <p>
  	ElementType.CONSTRUCTOR：作用于构造器（Constructor declaration）。<br />

  </p>
  <p>
  	ElementType.LOCAL_VARIABLE：作用于局部变量（Local variable declaration）。<br />

  </p>
  <p>
  	ElementType.ANNOTATION_TYPE：作用于注解（Annotation type declaration）。<br />

  </p>
  <p>
  	ElementType.PACKAGE：作用于包名上（Package declaration）。
  </p>
  <p>
  	ElementType.TYPE_PARAMETER：（Type parameter declaration &nbsp;@since 1.8）。<br />

  </p>
  <p>
  	ElementType.TYPE_USE：（Use of a type &nbsp;@since 1.8）。<br />

  </p>
  <p>
  	<br />

  </p>
  <p>
  	@Retention
  </p>
  <p>
  	说明annotation注释其它程序时，起作用的范围，有以下几个参数：
  </p>
  <p>
  	RetentionPolicy.RUNTIME：运行时注解<br />

  </p>
  <p>
  	<span style="white-space:pre">	</span>（Annotations are to be recorded in the class file by the compiler and
  </p>
  <p>
  	<span style="white-space:pre">	</span>retained by the VM at run time, so they may be read reflectively.）。
  </p>
  <p>
  	<br />

  </p>
  <p>
  	RetentionPolicy.SOURCE：编译结束后消失（Annotations are to be discarded by the compiler）。<br />

  </p>
  <p>
  	<br />

  </p>
  <p>
  	RetentionPolicy.CLASS：编译时注解
  </p>
  <p>
  	<span style="white-space:pre">	</span>（Annotations are to be recorded in the class file by the compiler
  </p>
  <p>
  	<span style="white-space:pre">	</span>but need not be retained by the VM at run time. &nbsp;This is the default<br />
  	&nbsp; &nbsp; &nbsp; &nbsp; behavior.）。<br />

  </p>
  <p>
  	<br />

  </p>
  <p>
  	@Inherited
  </p>
  <p>
  	若A_annotation被@Inherited修饰了，则A_annotation修饰其它类时，该类的子类会自动继承该注解。
  </p>
  <p>
  	<br />

  </p>
  <p>
  	获取注解
  </p>
  <p>
  	获取类上的注解
  </p>
  <p>
  	Class c;
  </p>
  <p>
  	c.isAnnotationPresent(XxxAnnotation.class);
  </p>
  <p>
  	c.getAnnotation(XxxAnnotation.class);
  </p>
  <p>
  	获取方法上的注解
  </p>
  <p>
  	Method m;
  </p>
  <p>
  	m.isAnnotationPresent(XxxAnnotation.class);<br />

  </p>
  <p>
  	m.getAnnotation(XxxAnnotation.class);<br />

  </p>
  <p>
  	获取字段上的注解
  </p>
  <p>
  </p>
  <p>
  	Field f;
  </p>
  <p>
  	f.isAnnotationPresent(XxxAnnotation.class);<br />

  </p>
  <p>
  	f.getAnnotation(XxxAnnotation.class);
  </p>
  <br />

  <p>
  	<br />

  </p>
  <p>
  	<br />

  </p>



  <footer class="site-footer">

    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
  </footer>

</section>


</body>
